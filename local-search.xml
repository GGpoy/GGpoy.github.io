<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>week-01</title>
    <link href="/2024/06/03/Week-01/"/>
    <url>/2024/06/03/Week-01/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><ol><li><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><p>计算机中，每一个0或1，叫做一个比特（bit）。</p><p>十进制转二进制:除2取余法</p><p>二进制转十进制：按权相加法</p></li><li><h2 id="计算机的存储单元"><a href="#计算机的存储单元" class="headerlink" title="计算机的存储单元"></a>计算机的存储单元</h2><p>最小的信息存储单元：位（比特位、bit），小写字母b表示</p><p>最小的数据存储单元：：字节（byte），大写字母B表示</p><p>1B&#x3D;8b<br>1KB &#x3D; 1024B<br>1MB &#x3D; 1024KB<br>1GB &#x3D; 1024MB<br>1TB &#x3D; 1024GB</p></li><li><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>给包、类、方法 、变量等起的名字</p><p>组成规则：<br> 字母、数字、下划线、$符号组成<br> 不能以数字开头<br> 不能为JAVA中关键字</p><p>命名规则：<br>包：域名倒过来，所有字母小写<br>类：单词首字母大写（驼峰命名）<br>方法：首单词的首字母小写，其他单词首字母大写<br>常量：所有字母大写</p></li><li><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>基本数据类型：int、short、long、float、double、char、byte、boolean</p><p>引用数据类型：类、对象、数组等</p><p>基本数据类型比较“值”，引用数据类型比较“地址”</p><table><thead><tr><th align="center">数据类型**</th><th align="center"><strong>关键字</strong></th><th align="center"><strong>内存占用</strong></th><th align="center"><strong>取值范围</strong></th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">字节型</td><td align="center">byte</td><td align="center">1个字节</td><td align="center">-128~127</td><td align="center">8位，2^7-1</td></tr><tr><td align="center">短整型</td><td align="center">short</td><td align="center">2个字节</td><td align="center">-32768~32767</td><td align="center">16位，2^15-1</td></tr><tr><td align="center">整型</td><td align="center">int（整数默认）</td><td align="center">4个字节</td><td align="center">-2的31次方~2的31次方-1</td><td align="center">默认值为0</td></tr><tr><td align="center">长整型</td><td align="center">long</td><td align="center">8个字节</td><td align="center">-2的63次方~2的63次方-1</td><td align="center">定义long类型的数据时，要在数据后面加L</td></tr><tr><td align="center">单精度浮点数</td><td align="center">float</td><td align="center">4个字节</td><td align="center">1.4013E-45~3.4028E+38</td><td align="center">定义float类型的数据时，要在数据后面加F</td></tr><tr><td align="center">双精度浮点数</td><td align="center">double（浮点数默认）</td><td align="center">8个字节</td><td align="center">4.9E-324~1.7977E+308</td><td align="center">默认值为0.0</td></tr><tr><td align="center">字符型</td><td align="center">char</td><td align="center">2个字节</td><td align="center">0-65535</td><td align="center">用单引号，例如’A’,’b’,’陈’</td></tr><tr><td align="center">布尔类型</td><td align="center">boolean</td><td align="center">1个字节</td><td align="center">true，false</td><td align="center">默认值为false</td></tr></tbody></table><p>注意：浮点型可能只是一个近似值，并非精确的值。如0.09+0.01&#x3D;0.9999999…. </p></li><li><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>取值范围小的数据类型与取值范围大的数据类型进行运算,会先将小的数据类型提升为大的,再运算</p><p>强制类型转换的格式：<br>b &#x3D; (byte)(a + b);<br>注意：如果超出了被赋值的数据类型的取值范围得到的结果会与你期望的结果不同</p></li><li><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><p>+、-、*、&#x2F;、%、++、–</p><p>运算中如出现不同类型的数据，结果将是数据范围类型大的那种</p></li><li><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>复合运算符中隐含了一个强制类型转换</p></li><li><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>&amp;、|、^（异或）、~（取反）、！、&amp;&amp;、||</p><p>&amp;&amp;、||具有短路效果，当根据左边已经判断出表达式的真假时，右边代码将不执行，以此提高性能</p></li><li><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>（关系表达式）？表达式1：表达式2</p></li><li><h2 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h2><p>&gt;&gt; 有符号右移：正数右移，高位补0，负数右移，高位补1</p><p>&gt;&gt;&gt; 无符号右移：无论正数或负数发生右移时，高位都直接补0</p><p>&lt;&lt; 左移：值变大，低位补0</p></li><li><h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>if（关系表达式）{</p><p>语句体</p><p>}</p><hr><p>if（关系表达式1）{</p><p>语句体1；</p><p>}else fi（关系表达式2）{</p><p>语句体2；</p><p>}else{</p><p>语句体n+1；</p><p>}</p></li><li><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>switch（表达式）{</p><p>case 值1：</p><pre><code class="hljs">        语句体；        break;</code></pre><p>case 值2：</p><pre><code class="hljs">        语句体；        break;</code></pre><p>…</p><p>default:</p><pre><code class="hljs">        语句体n+1；        break;</code></pre><p>}</p></li><li><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>for(初始化语句；判断条件语句；控制条件语句){</p><p>循环体语句；</p><p>}</p><p>控制条件语句中的变量，在for循环结束后就从内存中消失了</p></li><li><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>初始化表达式</p><p>while（布尔表达式）{</p><pre><code class="hljs">    循环体语句；    控制条件语句；</code></pre><p>}</p></li><li><h2 id="do…while循环"><a href="#do…while循环" class="headerlink" title="do…while循环"></a>do…while循环</h2><p>初始化表达式</p><p>do{</p><p>循环体语句；</p><p>控制条件语句；</p><p>}while(布尔表达式)；</p></li><li><h2 id="控制循环语句"><a href="#控制循环语句" class="headerlink" title="控制循环语句"></a>控制循环语句</h2><p>break的使用场景：<br>在选择switch语句中<br>在循环语句中</p><p>continue：<br>在循环语句中</p></li><li><h2 id="随机数Random"><a href="#随机数Random" class="headerlink" title="随机数Random"></a>随机数Random</h2><p>Random r &#x3D;new Random();</p></li><li><h2 id="Math产生随机数"><a href="#Math产生随机数" class="headerlink" title="Math产生随机数"></a>Math产生随机数</h2><p>Math.random（）无需导包，产出的是[0-1）的随机小数</p></li><li><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>存储多个变量，这变量的数据类型要一致。</p><p>一维数组的定义：数据类型[ ] 数组名</p><p>数组的动态初始化：指定数组长度而不分配内容，例如String[ ] arr &#x3D; new arr[10]</p><p>数组的静态初始化：指定数组的内容，由系统决定数组的长度，例如：String[ ] arr&#x3D;{“张三”、”李四”、”王五”}</p></li><li><h2 id="数组的内存分配"><a href="#数组的内存分配" class="headerlink" title="数组的内存分配"></a>数组的内存分配</h2><p>栈：存储局部变量，使用完毕立即回收</p><p>堆：存储成员变量以及对象，使用结束后会被垃圾回收器在空闲时候回收</p></li><li><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>函数即方法，是完成特定功能的代码块</p><p>方法语法：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">修饰符 返回值类型/<span class="hljs-keyword">void</span> 方法名(数据类型 参数名<span class="hljs-number">1</span>，数据类型 参数名<span class="hljs-number">2</span>…) &#123;<br><br><span class="hljs-comment">//方法体</span><br><br>    <span class="hljs-comment">//没有返回值 return;</span><br><span class="hljs-keyword">return</span> 返回值;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><h2 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h2><p>方法签名（方法名和形参列表）不同即为重载，与返回值类型无关</p></li><li><h2 id="参数的传递"><a href="#参数的传递" class="headerlink" title="参数的传递"></a>参数的传递</h2><p>方法的形参为基本数据类型时，形参的改变不影响实参</p><p>方法的形参为引用数据类型时（String除外，String作为常量存在于常量池里），形参的改变直接影响实参</p></li><li><p>String类</p><p><strong>字符串是常量，一旦赋值，就不能改变</strong></p><p>通过构造方法创建的字符串对象在堆内存<br>直接赋值的方式创建对象是在方法区的常量池</p><hr></li></ol><h1 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h1><ol><li><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>类：一组相关属性和行为的集合，比如学生就是一个类<br>对象：该类事务的具体实例，比如学生“张三”就是一个具体实例</p><p>成员变量：定义在方法外的变量，是事物的属性，系统会默认设置初始值<br>成员方法：事务的行为</p><p>类的定义：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe">修饰符 <span class="hljs-title class_"><span class="hljs-keyword">class</span> 类名</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>对象的创建：<br>类名 对象名 &#x3D; new 类的构造方法（）；</p><p>成员的访问：<br>成员变量的访问：对象.成员变量<br>成员方法的访问：对象.成员方法（）</p></li><li><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>分包管理是组织软件项目结构的基本方式。<br>包在文件系统中以文件夹的形式存在。</p><p>被使用的类与使用类不在同一文件夹下，通过导包的方式使用该类</p></li><li><h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><table><thead><tr><th></th><th>public</th><th>protected</th><th>空的(default)</th><th>private</th></tr></thead><tbody><tr><td>同一类中</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>同一包中(子类与无关类)</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>不同包的子类</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>不同包中的无关类</td><td>√</td><td></td><td></td><td></td></tr></tbody></table></li><li><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>属性隐藏，提供公共方法对其访问</p><p>成员变量用private修饰，提供对应的get&#x2F;set方法</p></li><li><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>this：所在类对象的引用（方法被哪个对象调用，this就代表哪个对象）</p></li><li><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>对对象的数据进行初始化</p><p>方法名与类名相同，无返回值</p><p>创建类时，系统会自动给出无参构造，当自己写了构造方法时，系统将不再提供</p></li><li><h2 id="标准类的写法"><a href="#标准类的写法" class="headerlink" title="标准类的写法"></a>标准类的写法</h2><p>成员变量<br>构造方法：<br>无参构造<br>有参构造<br>成员方法：<br>getXxx（）<br>setXxx（）</p></li><li><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>使用extends关键字完成继承关系</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">子类</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">父类</span></span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>Object为所有类的父类（超类）</p><p>当父类的成员变量用private修饰后,子类无法访问父类的成员变量,但是如果父类提供了public修饰的get&#x2F;set方法,则子类可以通过get&#x2F;set方法,正常访问父类的成员变量</p></li><li><h2 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h2><p>子类继承父类方法后，通过定义一个与父类方法签名且返回类型一样的方法，但方法体重写。<br>父类的static方法可以被子类继承，但不能被子类重写</p><p>重写的方法访问权限只能大于等于父类被重写的方法</p></li><li><h2 id="super访问父类的构造方法"><a href="#super访问父类的构造方法" class="headerlink" title="super访问父类的构造方法"></a>super访问父类的构造方法</h2><p>​    this(其他参数)    可以访问本类其他的构造方法</p><p>​    super(其他参数)   可以访问父类其他的构造方法</p><p>子类的每个构造方法中均有默认的super(),调用父类的空参构造。手动调用父类构造会覆盖默认的super();</p></li><li><h2 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h2><p>一个类作为另一个类的属性类型存在</p></li><li><h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><p>一个类作为另一个类的形参类型</p></li><li><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>成员变量按照有无static修饰分为类变量和实例变量</p><p><img src="/../image/b951e3fa5f5414ad7f4f715ae6f98869.png" alt="screen-capture"></p><p>类变量的访问：类名.类变量（推荐）、对象名.类变量（不推荐）</p><p>类变量与类一起加载一次，在内存中只有一份，被类的所有对象共享，生命周期与类共存亡</p><p>类方法的好处：</p><p><img src="/../image/7a7efcf2fe30a78a5168bc1ed210236b.png"></p><p>实例方法的调用需要创建对象去调用，而对象会占用堆内存，若此时该对象仅仅为了调用该方法，就会浪费内存。<br>而类方法直接使用类名调用，jvm会直接在方法区执行方法，不占用堆或栈的内存。<br>tips：在创建工具类时，例如上面的验证码的生成，建议使用私有构造函数。仅通过类名去调用工具类方法就可以了，没有必要去创建对象来调用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> a;<span class="hljs-comment">//类变量</span><br>    <span class="hljs-type">int</span> b;<span class="hljs-comment">//实例变量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print1</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>&#123;<br>        <span class="hljs-comment">//类方法</span><br>        A.a=<span class="hljs-number">5</span>;<span class="hljs-comment">//类方法中，可以直接访问类成员</span><br>        A.b=<span class="hljs-number">4</span>;<span class="hljs-comment">//类方法中，不能直接访问实例成员</span><br>        <span class="hljs-built_in">this</span>.a=a;<span class="hljs-comment">//类方法中，不能出现this关键字（因为a变量可以被类名直接访问，而this是对象的引用，此时可能没有任何对象）</span><br>    &#125;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">print2</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//实例方法</span><br>        a=<span class="hljs-number">3</span>;<span class="hljs-comment">//实例方法中，可以直接访问类成员</span><br>        b=<span class="hljs-number">3</span>;<span class="hljs-comment">//实例方法中，可以直接访问实例成员</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>用于修饰类、方法、变量</p><p>类：被修饰的类，不能被继承。</p><p>方法：被修饰的方法，不能被重写。</p><p>变量：被修饰的变量，有且仅能被赋值一次。</p></li><li><h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><p>抽象类：包含抽象方法的类<br>抽象方法：没有方法体的方法</p><p>抽象类的定义：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> 类名 </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>抽象方法的定义：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> 返回值类型 方法(参数);<br></code></pre></td></tr></table></figure></li><li><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>确保系统一个类只有一个对象</p><p>懒汉式单例<br>先不创建实例对象，等用的时候才创建</p><ol><li><p>私有构造方法<br>private 类名（）{<br>}</p></li><li><p>定义一个变量用来接收类对象<br>private static 类名 变量名 ;</p></li><li><p>定义类方法，返回类变量<br>public static getInstance(){<br>if(变量&#x3D;&#x3D;null){<br>变量名&#x3D;new 类名（）；<br>}<br>return 变量名；<br>}</p><hr></li></ol><p>饿汉式单例<br>在使用类的时候就已经将对象创建完毕，无论是否用到该实例化对象</p><ol><li>私有构造方法<br>private 类名（）{<br>}</li><li>定义一个变量用来接收类对象<br>private static 类名 变量名 &#x3D;new 类名（）;</li><li>定义类方法，返回类变量<br>public static 类名 getObject(){<br>return 变量名；<br>}</li></ol></li><li><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>描述所应该具备的方法，具体的实现由接口的实现类来完成。</p><p>使用interface关键字定义接口</p><p>特点：<br>接口中的方法均为公共访问的抽象方法，程序默认有public abstract<br>接口中无法定义普通成员变量，均为静态常量，程序默认有public static final，需赋初始值</p><p>接口的实现：<br>接口不可以创建对象，但可以被类所实现，关键字为implements。<br>如果一个类实现了接口，但没有重写接口的所有抽象方法，这个类也必须定义为抽象类</p><p>格式：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe">修饰符 <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> </span>接口1，接口2，接口3...</span>&#123;<br>重写接口中的方法<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>day-2</title>
    <link href="/2024/05/28/day-2/"/>
    <url>/2024/05/28/day-2/</url>
    
    <content type="html"><![CDATA[<p>方法在计算机中的执行原理：方法被调用时，进入栈内存运行，先进后出。</p><p><img src="/../image/93013c35691c72b8916cd7a316b7e901.png"></p><br/><p>基本数据类型：值传递<br>引用数据类型：地址传递</p><br/><p>this主要为了解决局部变量和成员变量的同名问题</p><br/><p>有参构造与无参构造<br>定义：创建一个类时，编译器会自动添加无参构造方法（默认构造方法），若自己手动添加构造方法（有参或无参），默认构造方法都将无效。</p><p>有参构造方法：</p><p><img src="/image/380da3fa726421ffbc7caebd56b3cfe6.png" alt="screen-capture"></p><p><img src="/image/28f38b49b7e7902fed85e3641ce3eb4f.png"></p><p>通过有参构造，创建对象时可以直接进行属性赋值，而不用对象名.属性名的方法。</p><p>无参构造方法：</p><br/><p><img src="/image/73cabc220db2357d393df694bf342b5e.png"></p><br/><p>封装：使一部分成员充当类与外部的接口，而将其他的成员隐藏起来。</p><br/><p>继承：<br>关键字extends，子类继承父类的非私有成员</p><p>子类的对象由子类和父类同时完成</p><p>单继承，一个类只能继承一个直接父类</p><p>子类的构造方法中，默认有super()，指向父类的无参构造方法，故先调用父类构造方法，再调用子类构造方法。若父类没有无参构造方法（只有有参构造方法），需要手写super（）去调用父类有参构造</p><br/><p>权限修饰符：<img src="/image/a51922c6d03d504603839e48c84857c9.png" alt="截图"></p><br/><p>Object类：所有类的祖宗类</p><br/><p>方法的重写：<br>重写方法的返回值类型、形参类型、形参的顺序、形参的数量必须与被重写方法相同。</p><p>写重写方法前，使用Override注解，提高代码可读性</p><p>重写方法的访问权限必须大于等于被重新方法的        public&gt;protected&gt;缺省</p><p>私有方法和静态方法不能被重写</p><br/><p>this拓展：</p><p>当一个类的对象实例化时需要一个默认值，可以通过多个有参构造来实现对对象的赋值。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Day-1</title>
    <link href="/2024/05/26/day-1/"/>
    <url>/2024/05/26/day-1/</url>
    
    <content type="html"><![CDATA[<p>命名规则：<br>包：所有字母小写<br>类或接口：单词首字母大写<br>方法或变量：首单词的首字母小写，其余单词首字母大写<br>常量：所有字母大写，多单词用下划线_区分</p><br/><p>8大基本数据类型：<br>整数类型：byte、short、int、long<br>小数类型：float、double<br>字符类型：char<br>布尔类型：boolean</p><br/><p>引用数据类型：<br>类、接口、数组、枚举、注解、字符串等</p><br/><p>算数运算符++、–的用法：<br>i++,先赋值，再运算<br>++i,先运算，再赋值</p><br/><p>逻辑运算符：<br>位运算符、逻辑运算符：&amp;、|、^<br>逻辑运算符：！、&amp;&amp;、||<br>&amp;&amp;与&amp;的区别：<br>当根据的表达式左边或右边已经可以判断出整个表达式的真假时，&amp;&amp;将不再执行代码，从而节省性能。<br>&amp;可作为位运算符，进行二进制间的计算</p><br/><p>switch语句：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">switch</span>(表达式)&#123;<br>      <span class="hljs-keyword">case</span> 值：<br>      语句体<br>      <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> 值：<br>      语句体<br>      <span class="hljs-keyword">break</span>;<br>      ...<br>      <span class="hljs-keyword">default</span>:<br>      语句体<br>      <span class="hljs-keyword">break</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意点：switch语句的原理是跳转到case值的位置执行下面的所有语句，包括其他case里面的值，直到最后或者遇到break。</p><br/><p>for循环语句和while循环的区别：<br>控制条件语句的变量，在for循环结束后便不能被访问，而while循环结束后还可以继续使用。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>仅以此博客记录我的学习生活</title>
    <link href="/2024/05/24/%E4%BB%85%E4%BB%A5%E6%AD%A4%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95%E6%88%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%94%9F%E6%B4%BB/"/>
    <url>/2024/05/24/%E4%BB%85%E4%BB%A5%E6%AD%A4%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95%E6%88%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%94%9F%E6%B4%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="Begin"><a href="#Begin" class="headerlink" title="Begin:"></a>Begin:</h2><p>万事开头难，生活如此，学习亦是如此。</p><p>努力不一定成功，但不努力只能喝西北风。</p><p>所以，请坚持下去   :)</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
